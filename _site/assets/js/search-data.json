{"0": {
    "doc": "Messing with Flutter",
    "title": "Messing with Flutter",
    "content": "Beberapa eksperimen menggunakan framework flutter untuk membangun aplikasi android . ",
    "url": "http://localhost:4000/flutter_1.html",
    "relUrl": "/flutter_1.html"
  },"1": {
    "doc": "Flutter Cheatsheet",
    "title": "Flutter Cheatsheet",
    "content": "Catatan, tips &amp; trick . ",
    "url": "http://localhost:4000/flutter_2.html",
    "relUrl": "/flutter_2.html"
  },"2": {
    "doc": "Alternatif Nested List",
    "title": "Alternatif Nested List",
    "content": "Bagaimana cara mengimplementasikan tampilan seperti ini di flutter? . Pilihan pertama kita jatuh pada nested listview, seperti dibawah ini . ListView( controller: scrollController, children: [ Container( height: 150, child: Center( child: Text(\"Header\"), ), ), ListView.builder( shrinkWrap: true, physics: NeverScrollableScrollPhysics(), itemBuilder: (ctx, index){ }) ] ) . Pada cara ini, kita menempatkan sebuah listview di dalam listview lainnya, sehingga kita mendapatkan efek scrolling seperti pada video. Perlu diperhatikan, listview di dalam widget dengan fungsi scroll memerlukan parameter shrinkWrap bernilai true, yang artinya fungsi lazy load dari listview tidak berfungsi. Apabila fungsi lazy load dimatikan, maka setiap item dalam listview akan mengalami rebuild setiap kali data dalam listview di update. Kita bisa memastikannya dengan membuka panel Flutter Performance. Setelah melakukan scrolling, Flutter Performance menunjukkan aktivitas berikut . Pada panel Flutter Performance kita bisa melihat widget yang di build pada frame terakhir berjumlah 80, sementara yang terjadi pada saat kita melakukan scrolling adalah listview menampilkan 10 buah item baru. Kemungkinannya adalah, listview melakukan rebuild pada 70 item yang dimuat, baik item baru maupun item lama. Melakukan rebuild pada seluruh listview bisa berdampak pada performa aplikasi jika jumlah muatan listview semakin banyak. Saat kita melakukan scrolling pada halaman 100 misalnya, maka aplikasi melakukan rebuild pada 1000 item dalam satu kali scroll. Hal ini bisa membahayakan performa aplikasi. Sebagai alternatif, kita bisa menggunakan CustomScrollView untuk menghasilkan efek scroll bertingkat tanpa menggunakan parameter shrinkWrap. Maka dengan mengganti ListView terluar dengan CustomScrollView, kita bisa mendapatkan tampilan yang sama dengan code berikut . CustomScrollView( controller: scrollController, slivers:[ SliverToBoxAdapter( child: Container( height: 150, child: Center( child: Text(\"Header\"), ), ), ), SliverList( delegate: SliverChildBuilderDelegate( (context, index) { } )) ] ) . Karakteristik dari CustomScrollView adalah child yang ada harus berupa Sliver Widget, sehingga kita perlu menggantikan ListView dengan SliverList. Untuk melihat bagaimana performa dari code ini, kita melakukan pengecekan pada Flutter Performance dengan case yang sama, dan berikut hasil scrolling hingga ke item 70 pada aplikasi yang sudah kita perbarui . Dengan improvement yang telah kita lakukan, sekarang jumlah rebuild yang dilakukan aplikasi dalam sekali scroll berjumlah konstan pada angka 16. ",
    "url": "http://localhost:4000/flutter_nested_list.html",
    "relUrl": "/flutter_nested_list.html"
  },"3": {
    "doc": "About",
    "title": "About",
    "content": "This is a blog about my coding experience. I am a tech enthusiast and a software engineer. I have a passion for technology that is both smart and easy to use. I believe that a good tech could easily support many needs, and that’s drive me to participate in development of things that is easy to use, like flutter c: . You can hit me up at my email or check out my artifacts on Github . ",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },"4": {
    "doc": "Enkripsi Konten Multimedia",
    "title": "Enkripsi Konten Multimedia",
    "content": "Pada umumnya tidak disarankan untuk menyimpan data berharga dalam aplikasi mobile. Sementara beberapa jenis data non-confidential contohnya konten berupa intellectual property, biasanya memiliki ukuran yang besar sehingga perlu disimpan secara permanen dalam memori device, sehingga memerlukan perlindungan enkripsi. Enkripsi biasanya dilakukan oleh pengirim data, misalnya penyimpanan data di cloud database menyimpan data dalam bentuk data enkripsi. Ketika akan digunakan data yang sudah dienkripsi perlu di dekripsi terlebih dahulu. Data hasil dekripsi perlu disimpan dalam memori sementara, yang akan dihapus ketika penggunaan data berakhir. Berikut adalah contoh use-case penggunaan data konten multimedia yang diunduh dari cloud server dalam bentuk enkripsi. Dengan use-case tersebut, user hanya bisa mengakses konten dari aplikasi yang kita buat. View on Github . ",
    "url": "http://localhost:4000/multimedia_encryption_example.html",
    "relUrl": "/multimedia_encryption_example.html"
  },"5": {
    "doc": "Play Asset Delivery in Flutter",
    "title": "Play Asset Delivery in Flutter",
    "content": "Now Playstore make possible flexible asset delivery by provide us with Play Asset Delivery functionality. We can use this functionality by using app-bundle distribution and Play Core Library for managing the distribution. This library provide us with functions for checking assets availability, assets downloading, and obtaining assets absolute path location. Meanwhile you can’t use Play Core Library directly with Flutter, so I make flutter_play_asset, a flutter package to access Play Core API for Play Asset Delivery functionality. This package implements the Play Core API in native part of the library in Kotlin, and use PlatformChannel to provide the function for managing the assets delivery to the flutter interface. I make a demo to implement this functionality, an application that use a lot of assets. I use modularization to separate the app by it’s functionalities, therefore I can easily devide the assets to a few parts. Then I decide which pack of assets which will be used later, and make the use case for user to obtains those assets later when they will actually need them. By doing so, I reduce the installation size by the size of the assets, in which for a few high res images each sized around 1 mb, it’s total in 18 mb. View on Github Try It as Tester! . So far flutter_play_asset is limited to only support play asset delivery feature for downloading asset pack with on-demand mode, so there still a lot of improvement need to be done to make this library perfect. I’m very open to feedback and any contribution to this project will be very much appreciated! . ",
    "url": "http://localhost:4000/play_asset_flutter.html",
    "relUrl": "/play_asset_flutter.html"
  },"6": {
    "doc": "Singleton Object",
    "title": "Singleton Object",
    "content": "Seringkali kita menggunakan sebuah service dalam aplikasi yang kita buat, dimana service tersebut tidak boleh memiliki duplikat. Untuk memastikan bahwa service yang kita buat hanya dapat memiliki satu buah copy dalam satu waktu, kita bisa membuat service sebagai singleton. Berikut bagaimana kita membuat sebuah singleton. class SingleCopyService { static final CreatSingleCopyServiceeProduct _singleton = SingleCopyService._internal(); factory SingleCopyService() { return _singleton; } SingleCopyService._internal(){ inProgress = false; } } . Dengan cara demikian, service akan di create dan diinisiasi jika belum dibuat. Kemudian jika Service dipanggil kembali, maka objek factory akan mereturn service yang telah dibuat. ",
    "url": "http://localhost:4000/singleton_service_example.html",
    "relUrl": "/singleton_service_example.html"
  },"7": {
    "doc": "State Management - Eventbus",
    "title": "State Management - Eventbus",
    "content": "Kita bisa menggunakan event bus untuk melakukan update state dari satu class ke class lain. Sebaiknya dalam sebuah aplikasi hanya digunakan sebuah eventbus untuk menghindari kesulitan pada proses debugging. Berikut ini adalah contoh penggunaan eventbus untuk mentrigger update state. Deklarasikan sebuah eventbus sebagai static object dan eventbus event dengan sebuah muatan string. class EventBusEvent{ final String message; EventBusEvent(this.message); } EventBus eventBus = EventBus(); . Kirim sebuah pesan menggunakan eventbus menggunakan perintah berikut. Pesan ini akan diterima oleh setiap komponen dalam aplikasi yang melakukan subskripsi ke event yang sesuai. eventBus.fire(EventBusEvent(\"Halo\")); . Inisiasi eventbus subscription di class yang akan merespon update data. class StateClassA extends State&lt;ClassA&gt; { StreamSubscription subscription; String messageState = \"\"; @override void initState() { super.initState(); subscription = eventBus.on&lt;EventBusEvent&gt;().listen((event) { setState(() { messageState = (event as EventBusEvent).message; }); } }); } . ",
    "url": "http://localhost:4000/state_management_eventbus_example.html",
    "relUrl": "/state_management_eventbus_example.html"
  },"8": {
    "doc": "State Management",
    "title": "State Management",
    "content": "Aplikasi state management dapat dilakukan dengan menggunakan design pattern seperti Provider, Bloc, dan ScopedModel. Sementara pada aplikasi yang sederhana kita bisa membuat state management tanpa design pattern. Implementasi demikian dapat dilakukan bila aplikasi memiliki tampilan sederhana dan pengembangan aplikasi dapat kita prediksi. Contoh dari tampilan yang sederhana adalah dimana kita bisa mendefinisikan widget ke dua kelompok, parent dan child, seperti tampilan ini. Pada tampilan ini, widget parent adalah container yang memuat seluruh halaman yang nampak. Widget child berupa komponen dalam tampilan, yaitu image selector dan image display. Perubahan state dapat kita lakukan dengan membuat fungsi di masing-masing widget. Bagaimana jika perubahan state sebuah widget mempengaruhi widget lainnya seperti ilustrasi ini? . Pada tampilan ini kita melakukan perubahan state pada beberapa widget. Widget child 1 menerima input saat user melakukan tap pada sebuah gambar. Kemudian widget child mengirim perubahan state ke parent widget. Kemudian parent widget mengirim perubahan state ke widget child 2. Maka kita bisa melakukan perubahan dengan cara berikut. | Mengubah child dari parent | . Untuk child widget, kita membuat sebuah fungsi callback yang mana sebuah fungsi di parent widget yang akan dipanggil dengan trigger dari child. class ChildWidget extends StatefulWidget { Function(Color, String, bool) callback; ToolsContainer(this.callback); @override State&lt;StatefulWidget&gt; createState() { return _ToolsContainer(); } } ... onTap: () { widget.callback(null, _sampleImages[position], false); }, . Kemudian pada parent widget, kita mendeklarasikan child widget seperti ini . child: new ToolsContainer(callback_set_background), . | Mengubah parent dari child Fungsi callback_set_background dalam widget parent akan ditrigger untuk melakukan perubahan pada child 2. Berikut ini bagaimana kita mentrigger perubahan child 2 dari parent. | . Widget parent kita bungkus dengan sebuah widget perantara yang kita namakan ParentProvider. class ParentProvider extends InheritedWidget { final String bgUrl; ParentProvider(this.bgUrl); @override bool updateShouldNotify(ParentProvider oldWidget) { return true; } static ParentProvider of(BuildContext context) =&gt; context.inheritFromWidgetOfExactType(ParentProvider); } . Di parent provider kita menyimpan setiap value milik parent widget yang akan diekspos ke widget child. Sehingga, ketika salah satu value tersebut mengalami perubahan widget child akan otomatis terupdate. Kita menempatkan widget parent dalam parent provider, sehingga fungsi build akan nampak seperti ini. @override Widget build(BuildContext context) { return new ParentProvider( recentStates[activeState]._chosen_image_url, new Scaffold()); } . Kemudian kita bisa menggunakan value milik parent dan menerima update di widget child dengan cara demikian . @override Widget build(BuildContext context) { final selectedBgUrl = ParentProvider.of(context).bgUrl; } . ",
    "url": "http://localhost:4000/state_management_example.html",
    "relUrl": "/state_management_example.html"
  }
}
